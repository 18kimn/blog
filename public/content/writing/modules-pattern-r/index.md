{"data":{"title":"The modules pattern in R","date":"2022-01-10T00:00:00.000Z"},"toc":[{"level":2,"slug":"what-are-modules-","title":"What are modules?"},{"level":3,"slug":"readability","title":"Readability"},{"level":3,"slug":"reproducibility","title":"Reproducibility"},{"level":3,"slug":"reusability","title":"Reusability"},{"level":2,"slug":"modularizing-your-code","title":"Modularizing your code"},{"level":3,"slug":"step-one-place-your-code-into-functions-and-those-functions-in-files","title":"Step one: place your code into functions, and those functions in files"},{"level":3,"slug":"step-two-give-each-file-their-own-scope","title":"Step two: give each file their own scope"},{"level":3,"slug":"step-three-organize-an-index-file","title":"Step three: organize an index file"},{"level":2,"slug":"caveats","title":"Caveats"},{"level":2,"slug":"alternatives","title":"Alternatives"},{"level":3,"slug":"r-markdown","title":"R markdown"},{"level":3,"slug":"third-party-packages","title":"Third-party packages"},{"level":3,"slug":"writing-your-own-personal-package","title":"Writing your own personal package"}],"content":"<h2 class=\"heading\" id=\"what-are-modules-\">What are modules?<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#what-are-modules-\">#</a></h2><p>A module is a file which runs code scoped only to that file,\nand &quot;exports&quot; a discrete and consistent number of items for use\nin another file. This usually meaning storing all logic in\nfunctions, and then calling those functions from other files so\nthat the logic inside may be run.</p>\n<p>Putting your code into modules allows you to component-ize your\ncode. Instead of one gigantic block of code, or an unending\n<code>dplyr</code> sentence, you can divide your code up into sections,\nplace them in their appropriate files, and recombine them.</p>\n<p>Here&#39;s an example of what the pattern could look like in R.\nDon&#39;t worry too much about the syntax, it&#39;ll be explained\nlater.</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-built_in\">library</span>(tidyverse)\nscrape_data &lt;- <span class=\"hljs-built_in\">source</span>(&quot;scrape_data.R&quot;)<span class=\"hljs-variable\">$value</span>\nclean_string_cols &lt;- <span class=\"hljs-built_in\">source</span>(&quot;clean_string.R&quot;)<span class=\"hljs-variable\">$value</span>\nclean_numeric_cols &lt;- <span class=\"hljs-built_in\">source</span>(&quot;clean_numeric.R&quot;)<span class=\"hljs-variable\">$value</span>\nrun_model &lt;- <span class=\"hljs-built_in\">source</span>(&quot;run_model.R&quot;)<span class=\"hljs-variable\">$value</span>\n\nmy_model &lt;- <span class=\"hljs-built_in\">scrape_data</span>() %&gt;%\n  <span class=\"hljs-built_in\">clean_string_cols</span>() %&gt;%\n  <span class=\"hljs-built_in\">clean_numeric_cols</span>() %&gt;%\n  <span class=\"hljs-built_in\">run_model</span>()</code></pre><p><code>scrape_data.R</code>, <code>clean_string.R</code>, <code>clean_numeric.R</code>, and\n<code>run_model.R</code> don&#39;t run any actual analysis or process data.\nInstead, they express <em>logic</em> to run code by defining a single\nfunction. When you import them with <code>source</code>, you assign those\nfunctions to functions you can use in an assembler or index\nfile.</p>\n<p>There are two benefits here: readability and reproducability.</p>\n<h3 class=\"heading\" id=\"readability\">Readability<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#readability\">#</a></h3><p>Someone reading the index file doesn&#39;t have see the minutia of\nwhat&#39;s going on; they see the abstractions and conceptual\nmeaning of the code through the names the writer gave it.\nInstead of seeing that R download a web page with <code>rvest</code> and\nlook for long and undecipherable Xpath or CSS tags, they see\n<code>scrape_data</code>, and sees that R scrapes data. Instead of seeing\nthat R parse a complicated regular expression to pull out\npatterns from strings, they see that R scrapes string data. And\nso on.</p>\n<p>When the user wants to see what is actually going on, they can\nsimply open up the imported files and see the logic of that\ncomponent. They don&#39;t have to look at the web scraping hen they\nwant to understand the data cleaning. They don&#39;t have to look\nat the data cleaning if they want to understand the model.\nLogic is broken up into chunks, organized into functions in\nfiles and made interpretable through naming.</p>\n<p>Perhaps most magical at all, we are now well on our way to\nself-documenting code. We don&#39;t have to write a comment saying\n&quot;this code scrapes data from XYZ, cleans it by doing ABC, and\nruns PQR model.&quot; The names of our functions naturally imply\nthis, and in the files defining each function, comments can\nsimilarly be omitted or be made considerably shorter through\nthis form of expressive code.</p>\n<p>Finally, the sort of converse of this process of making code\neasier for readers to understand, is that it also forces the\nwriter to understand their own code. It requires the writer to\ntake a step back and analyze the logic of their code instead of\nfocusing on small details, and organize their code in a way\nthat expresses that logic. Organizing requires reflecting;\nreflecting leads to understanding.</p>\n<h3 class=\"heading\" id=\"reproducibility\">Reproducibility<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#reproducibility\">#</a></h3><p>Firstly, by making your code more readable, you make your code\nreproducible. That is fairly intuitive, I don&#39;t really know how\nto explain it other than that.</p>\n<p>But this pattern offers more reproducible code with two items:\nscoped environments and pipe-able code. Let&#39;s take a look at a\ncontrived example of how a novice programmer might write code\nwith and without the tidyverse:</p>\n<pre><code class=\"hljs r\">dta &lt;- read.csv(<span class=\"hljs-string\">&quot;path_to_data.csv&quot;</span>)\n<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span> &lt;- dta$old_col * <span class=\"hljs-number\">2</span>\ndta$<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span> &lt;- <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span>\ndta &lt;- dta[<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span> &gt; <span class=\"hljs-number\">5</span>]\ndta &lt;- dta[<span class=\"hljs-string\">&quot;new_col&quot;</span>]\n\n<span class=\"hljs-meta\"># compare this to</span>\nlibrary(tidyverse)\ndta &lt;- read_csv(<span class=\"hljs-string\">&quot;path_to_data.csv&quot;</span>) %&gt;%\n  mutate(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span> = old_col * <span class=\"hljs-number\">2</span>) %&gt;%\n  filter(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span> &gt; <span class=\"hljs-number\">5</span>) %&gt;%\n  select(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_col</span>)</code></pre><p>You might notice that there are some readability improvements\nthat the pipe brings, letting you chain things together and\nconnecting logic. The pipe is like the word &quot;and&quot; in English,\nconnecting logical parts of code together in ways we can more\neasily understand.</p>\n<p>But it also makes code more <em>reproducible</em> because it forces\nthere to be only one way to run the code. If you were the\nnovice programmer ran <code>dta &lt;- read.csv(..)</code>, then immediately\nran <code>dta &lt;- dta[&quot;new_col&quot;]</code>, things would break; R doesn&#39;t\nrecognize &quot;new_col&quot;. Even worse, if you forgot to run\n<code>dta[new_col &gt; 5]</code> before running <code>dta[&quot;new_col&quot;]</code>, your code\nwould run but not in the way you meant it to. Your data would\nhave more rows without telling you anything went wrong, maybe\nleading to more difficult problems later. Finally, if you had\nan object already defined called <code>new_col</code> in the global\nenvironment, it has now been overwritten, preventing you from\ncalling back to it and potentially leading to a mistake if you\ndid not realize this happened.</p>\n<p>The pipe solves this issue by turning many commands into one.\nWith the pipe, there is no way to run a chain of commands\nbesides all of them. There are no intermediary variables, no\nways to overwrite an existing dataset or object. You cannot\nmess up the order, because the pipe does not let you. In the\nmodules pattern example, the pipe similarly forces a single way\nto run your code: in order, producing a single object at the\nend.</p>\n<p>This is a somewhat contrived example. Experienced R users might\nthink that of course it makes sense to run all of your code in\norder; of course it makes sense to manage your environment,\nperhaps with a generous helping of <code>rm(list=ls())</code>. But the\ntruth is that as you write more code, this becomes harder and\nharder. Projects with hundreds of lines of code or much more\ncan get out of hand. You might clean many datasets, you might\nhave to run many types of models, endlessly overwriting\nvariablaes called <code>dta</code> or <code>mod</code>. If you didn&#39;t overwrite them,\nthings might be even messier, with the creation of variables\nlike <code>mod_with_controls_propensity_weights_logged</code>.</p>\n<p>The general rule is this: the more intermediary objects you\nhave in your global environment, the less likely it is for your\ncode to be reproducible.</p>\n<p>Two items help with this. The first is the pipe, as shown\nabove. But the second are <em>scoped environments</em>, where\nvariables created do not modify the global environment. Here&#39;s\nan example:</p>\n<pre><code class=\"hljs r\">x <span class=\"hljs-operator\">&lt;-</span> 1\nmy_function <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-keyword\">function</span><span class=\"hljs-punctuation\">(</span>y<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">{</span>\n  x <span class=\"hljs-operator\">&lt;-</span> 2\n<span class=\"hljs-punctuation\">}</span>\nx</code></pre><p><code>my_function</code> here contains its own scope; even though it\ncreates a variable called <code>x</code>, the global environment knows\nnothing about it and is not bothered. When you have to make\nintermediary variables, doing them inside of these scoped areas\ncan be helpful for preventing leakage to other contexts.</p>\n<p>The pipe and scoped environments work together. If you have\nfunctions to contain scope but not a pipe, you might still be\nmaking intermediary variables when you might not want them. If\nyou use pipes but no functions, then at some points you run the\nrisk of running long pipe chains that become undecipherable.\nYou might also run into cases where you cannot use a pipe\nbecause a package you&#39;re using just doesn&#39;t work well with it;\n<code>spreg</code> is one common example for me. In these cases, if you do\nnot have scoped environments to contain them, you have to put\nitems in the global environment.</p>\n<p>The modules pattern puts these together. You write functions\nthat possibly contain their own intermediary variables, but\nthey don&#39;t leak out to the global scope. The global scope sees\nonly these functions,</p>\n<h3 class=\"heading\" id=\"reusability\">Reusability<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#reusability\">#</a></h3><p>A common reason people advocate for this style of coding is\nbecause it means one piece of code can be reused many times. To\nsome extent this is also useful in R; for example, if you are\nwriting a report and want to have a consistent style, it&#39;s\nuseful to have a theme defined somewhere. This way, you can\nchange the styling for many graphics with a single change:</p>\n<pre><code class=\"hljs r\">theme_report &lt;- function(<span class=\"hljs-keyword\">base_size </span>= <span class=\"hljs-number\">12</span>, <span class=\"hljs-keyword\">base_family </span>= <span class=\"hljs-string\">&quot;Lato&quot;</span>){\n  theme_bw(<span class=\"hljs-keyword\">base_size </span>= <span class=\"hljs-keyword\">base_size, </span><span class=\"hljs-keyword\">base_family </span>= <span class=\"hljs-keyword\">base_family) </span>+\n    theme(&lt;more code here&gt;)\n}</code></pre><p>To be honest, this doesn&#39;t really apply to most of the projects\nI work on, since much of my code is only meant to run once. I\nhave to write code for a specific dataset that has specific\nproblems, often problems that will appear nowhere else.</p>\n<p>Having reusable code would be supremely helpful for larger\nprojects, though, when you repeat a common task many differnt\ntimes. New Haven nonprofit\n<a target='_blank'  href=\"https://www.ctdatahaven.org/\">DataHaven</a>, for example,\nabsolutely needs reusable code for its town-level reports, so\nthat it can repeat one general set of analyses for all of the\ntowns in Connecticut.</p>\n<p>Even if you do not care about reusing your code elsewhere, I\nhope the benefits of readability (naming and separating your\nlogic) and reproducibility (keeping your code contained to its\nown environment) convince you of the usefulness of the module\npattern.</p>\n<h2 class=\"heading\" id=\"modularizing-your-code\">Modularizing your code<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#modularizing-your-code\">#</a></h2><h3 class=\"heading\" id=\"step-one-place-your-code-into-functions-and-those-functions-in-files\">Step one: place your code into functions, and those functions in files<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#step-one-place-your-code-into-functions-and-those-functions-in-files\">#</a></h3><pre><code class=\"hljs r\"># module<span class=\"hljs-selector-class\">.R</span>\nclean_data &lt;- <span class=\"hljs-built_in\">function</span>(.data){\n  <span class=\"hljs-selector-class\">.data</span> %&gt;%\n    <span class=\"hljs-attribute\">filter</span>(&lt;stuff&gt;) %&gt;%\n    <span class=\"hljs-built_in\">pivot_wider</span>(&lt;more stuff&gt;) %&gt;%\n    <span class=\"hljs-built_in\">select</span>(&lt;other logic&gt;)\n}</code></pre><p>This is the fairly straightforward step. Cut parts of your code\nand place them in separate files. Wrap them in calls to\n<code>function</code>, and name those functions with what you see fit. To\nbe pipeable, the functions should receive a data.frame as their\nfirst argument and return a data.frame. To fit tidyverse\nconventions, you can name the first argument <code>.data</code>.</p>\n<p>You can also think about the generalizability or the\nspecificity of your code. If you are writing logic that may be\nrepeated several times elsewhere, you might want to add\nadditional parameters to your functions so that they can be\nused in different and flexible ways. If you don&#39;t want to, this\nstep can take less than a minute.</p>\n<h3 class=\"heading\" id=\"step-two-give-each-file-their-own-scope\">Step two: give each file their own scope<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#step-two-give-each-file-their-own-scope\">#</a></h3><p>This can be fairly tricky, and exposes R&#39;s lack of a native\nmodule system.</p>\n<p>The intuitive way to separate code into files in R is to simply\ncall <code>source</code>. The problem is that within each file, unwated\nlogic may leak out into files that call them.</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-meta\"># submodule.R</span>\n<span class=\"hljs-title\">clean_data</span> &lt;- function(.<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>){\n  &lt;<span class=\"hljs-title\">logic</span>&gt;\n}</span>\n\n<span class=\"hljs-title\">vaidate_data</span> &lt;- function(.<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>){\n  &lt;<span class=\"hljs-title\">logic</span>&gt;\n}</span>\n\n<span class=\"hljs-meta\"># module.R</span>\n\n<span class=\"hljs-title\">source</span>(<span class=\"hljs-string\">&quot;submodule.R&quot;</span>)\n<span class=\"hljs-title\">process_data</span> &lt;- function(.<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>){\n  <span class=\"hljs-title\">clean_data</span>(.<span class=\"hljs-title\">data</span>) %&gt;%\n    &lt;<span class=\"hljs-title\">other</span> <span class=\"hljs-title\">logic</span>&gt;\n}</span></code></pre><p>Here, <code>module.R</code> only uses <code>clean_data</code>, but it has access to\n<code>validate_data</code> as well. What if <code>validate_data</code> overwrites a\nfunction with the same name?</p>\n<p>A similar example:</p>\n<pre><code class=\"hljs r\"># index<span class=\"hljs-selector-class\">.R</span>\n<span class=\"hljs-built_in\">source</span>(&#x27;module.R&#x27;)\n<span class=\"hljs-built_in\">source</span>(&#x27;extra_cleaners.R&#x27;)\n<span class=\"hljs-built_in\">process_data</span>(dta)</code></pre><p>Suppose <code>extra_cleaners.R</code> exports another function called\n<code>clean_data</code>. Then the <code>process_data</code> function from <code>module.R</code>\nwould not work as intended, because it would use the\n<code>clean_data</code> defined in <code>extra_cleaners</code> and not <code>submodule</code>.</p>\n<p>Of course, this is a contrived example. You might be able to\nsimply name your functions descriptively and specifically, and\navoid this problem. But as stated above, for large projects\nthis can get out of hand, and your variables might become\nunreasonably long.</p>\n<p>The &quot;R&quot; way to do this is to use the <code>local()</code> function while\nwriting a module and <code>local = TRUE</code> flag while importing it.</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-comment\"># module.R</span>\n<span class=\"hljs-built_in\">local</span>({\n  clean_data &lt;- <span class=\"hljs-built_in\">source</span>(<span class=\"hljs-string\">&quot;submodule.R&quot;</span>, <span class=\"hljs-built_in\">local</span> = TRUE)<span class=\"hljs-variable\">$value</span>\n  process_data &lt;- <span class=\"hljs-keyword\">function</span>(.data){\n    clean_data(.data) %&gt;%\n      &lt;other logic&gt;\n  }\n})\n\n<span class=\"hljs-comment\"># index.R</span>\nprocess_data &lt;- <span class=\"hljs-built_in\">source</span>(<span class=\"hljs-string\">&quot;index.R&quot;</span>, <span class=\"hljs-built_in\">local</span> = TRUE)<span class=\"hljs-variable\">$value</span>\nalternate_cleaner &lt;- <span class=\"hljs-built_in\">source</span>(<span class=\"hljs-string\">&quot;extra_cleaners.R&quot;</span>, <span class=\"hljs-built_in\">local</span> = TRUE)<span class=\"hljs-variable\">$value</span>\n&lt;more code&gt;</code></pre><p><code>local()</code> evaluates an expression in its own scope. If the last\nexpression in <code>local()</code> is the definition of an object, it&#39;ll\nput that object in an <code>$value</code>. <code>source</code>ing a file with a\n<code>local</code> wrapper will produce an object with that <code>$value</code>\nattribute; getting it will get the function we want.</p>\n<p>For some strange reason, <code>source</code> doesn&#39;t seem to respect\n<code>local</code>, and instead runs code in the global environment by\ndefault. <code>local = TRUE</code> fixes this.</p>\n<p>With this syntax, the <code>clean_data</code> function that <code>process_data</code>\nuses will always belong to the <code>submodule.R</code> environment, and\nwill not be overwritten no matter what is called in the parent\nenvironment.</p>\n<p>There are two disadvantages here. This first is that it is a\nbit wordy. Do we really have to call <code>local = TRUE</code> every time?\nOr <code>$value</code> every time? That seems like a hassle. I&#39;m not sure\nif there are any alternatives to <code>local = TRUE</code>, but <code>$value</code>\nhas two alternatives. The first is the <code>assign</code> function, which\ncan target the parent environment:</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-meta\"># module.R</span>\n<span class=\"hljs-keyword\">local</span>({\n  source(<span class=\"hljs-string\">&quot;submodule.R&quot;</span>, <span class=\"hljs-keyword\">local</span> = <span class=\"hljs-literal\">TRUE</span>)\n  process_data &lt;- function(.data){\n    clean_data(.data) %&gt;%\n      &lt;other logic&gt;\n  }\n  <span class=\"hljs-built_in\">assign</span>(<span class=\"hljs-string\">&quot;process_data&quot;</span>, process_data, pos = <span class=\"hljs-number\">2</span>)\n})\n\n<span class=\"hljs-meta\"># index.R</span>\nsource(<span class=\"hljs-string\">&quot;module.R&quot;</span>, <span class=\"hljs-keyword\">local</span> = <span class=\"hljs-literal\">TRUE</span>)\n<span class=\"hljs-meta\"># now process_data can freely be used here</span>\nprocess_data(...)</code></pre><p>The key argument here is <code>pos = 2</code>, which specifies the parent\nenvironment of <code>module.R</code>.</p>\n<p>The drawback to this is that exports cannot be renamed; another\nfile exporting <code>process_data</code> in this way will overwrite this\none. It&#39;s a bit better than calling <code>source()</code> with <code>local()</code>,\nsince we still have some sense of containers, but we are still\nleft with the possibility of conflict. I don&#39;t recommend this.</p>\n<p>Another alternative is to use an immediately invoked function\nexpression, or IIFE. This was popular in languages like\nJavaScript a few years ago. It goes like this:</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-comment\"># module.R</span>\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(){</span>\n  source(<span class=\"hljs-string\">&quot;submodule.R&quot;</span>, <span class=\"hljs-built_in\">local</span> = <span class=\"hljs-literal\">TRUE</span>)\n  process_data &lt;- <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(.<span class=\"hljs-title\">data</span>){</span>\n    clean_data(.data) %&gt;%\n      &lt;other logic&gt;\n  }\n  process_data\n})()\n\n<span class=\"hljs-comment\"># index.R</span>\nprocess_data &lt;- source(<span class=\"hljs-string\">&quot;module.R&quot;</span>, <span class=\"hljs-built_in\">local</span> = <span class=\"hljs-literal\">TRUE</span>)</code></pre><p>A function wrapped is created, but immediately invoked by\nwrapping the declaration in parentheses and inserting a pair of\nparentheses after the declaration. The wrapper parentheses tell\nR &quot;evaluate what&#39;s inside and give me the result&quot;, which will\nsimply give back a function, and the parentheses at the end\ntell R to invoke that function. The anonymous function will\nthen return <code>process_data</code>, and when called from another file\nallows it to be reassigned to another variable if necessary.\nThis is pretty close to <code>local()</code>, and avoids the <code>$value</code>\nsyntax, but I&#39;m not sure if it&#39;s any easier to read or write.\nYour preference!</p>\n<p>The second drawback of this pattern is that you can only have\none export per file. We can force our way into having multiple\nfunctions defined in a single file by putting them all in a\nsingle list:</p>\n<pre><code class=\"hljs r\"># module<span class=\"hljs-selector-class\">.R</span>\n<span class=\"hljs-built_in\">local</span>({\n  clean_data &lt;- source(&quot;submodule.R&quot;, local = TRUE)<span class=\"hljs-variable\">$value</span>\n  process_data &lt;- <span class=\"hljs-built_in\">function</span>(.data){\n    <span class=\"hljs-built_in\">clean_data</span>(.data) %&gt;%\n      &lt;other logic&gt;\n  }\n\n  clean_data &lt;- <span class=\"hljs-built_in\">function</span>(.data){\n    &lt;more stuff&gt;\n  }\n  <span class=\"hljs-built_in\">list</span>(process_data = process_data, clean_data = clean_data)\n})\n\n# index<span class=\"hljs-selector-class\">.R</span>\nprocess_data &lt;- <span class=\"hljs-built_in\">source</span>(&quot;module.R&quot;)<span class=\"hljs-variable\">$value</span><span class=\"hljs-variable\">$process_data</span>\nclean_data &lt;- <span class=\"hljs-built_in\">source</span>(&quot;module.R&quot;)<span class=\"hljs-variable\">$value</span><span class=\"hljs-variable\">$clean_data</span></code></pre><p>Unfortunately, that&#39;s still a bit wordy and obtuse.</p>\n<p>The other slightly annoying part of this is in loading\nlibraries. To be truly scoped, we want to load a library only\nfor a particular module. There isn&#39;t really a nice way to do\nthis. You can technically load a library, execute code, and\ndetach the library if needed:</p>\n<pre><code class=\"hljs r\"># module<span class=\"hljs-selector-class\">.R</span>\n<span class=\"hljs-built_in\">local</span>({\n  clean_data &lt;- source(&quot;submodule.R&quot;, local = TRUE)<span class=\"hljs-variable\">$value</span>\n  process_data &lt;- <span class=\"hljs-built_in\">function</span>(.data){\n    already_has_dplyr &lt;- (&quot;package:dplyr&quot; %in% search())\n    <span class=\"hljs-built_in\">library</span>(dplyr)\n\n    result &lt;- <span class=\"hljs-built_in\">clean_data</span>(.data) %&gt;%\n      &lt;other logic&gt;\n    <span class=\"hljs-built_in\">if</span>(!already_has_dplyr) <span class=\"hljs-built_in\">detach</span>(&quot;package:dplyr&quot;)\n    <span class=\"hljs-built_in\">return</span>(result)\n  }\n})</code></pre><p>But this to me is unreasonable and makes code harder to read\nand write, not easier.</p>\n<p>The alternative is to use the <code>::</code> notation, and use\n<code>dplyr::select</code> and so on. This is what Google recommends in\ntheir\n<a target='_blank'  href=\"https://google.github.io/styleguide/Rguide.html\">R style guide</a>.\nFor infix functions like <code>%&gt;%</code>, you can import them with\n<code>%&gt;% &lt;- purrr::%&gt;%</code>. There&#39;s likely a way to do this for\nmethods too, so that functions like <code>plot</code> and so on work\nproperly. But these strategies to me are still messy and make\ncode harder to read and write. I recommend either loading\nlibraries at the top of files that actually execute functions\nand nowhere else, or at the top of every file that uses a call\nto a function. You can also use the <code>conflicted</code> package if you\nare worried about this scenario.</p>\n<p>In any case, here is the point where we reach the ends of R. R\ndoesn&#39;t have a built-in module system, so trying to manage\nscopes ourselves sometimes doesn&#39;t mesh well with the rest of R\nsyntax.</p>\n<h3 class=\"heading\" id=\"step-three-organize-an-index-file\">Step three: organize an index file<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#step-three-organize-an-index-file\">#</a></h3><p>Step one might be all you need to organize your code, and step\ntwo might be all you need to keep your code squeaky clean. But\nonce you have your code organized into functions, you usually\nneed to write a few lines of code to actually execute your\ncode. We can finally write the code that I placed at the top of\nthis doc:</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-built_in\">library</span>(tidyverse)\nscrape_data &lt;- <span class=\"hljs-built_in\">source</span>(&quot;scrape_data.R&quot;)<span class=\"hljs-variable\">$value</span>\nclean_string_cols &lt;- <span class=\"hljs-built_in\">source</span>(&quot;clean_string.R&quot;)<span class=\"hljs-variable\">$value</span>\nclean_numeric_cols &lt;- <span class=\"hljs-built_in\">source</span>(&quot;clean_numeric.R&quot;)<span class=\"hljs-variable\">$value</span>\nrun_model &lt;- <span class=\"hljs-built_in\">source</span>(&quot;run_model.R&quot;)<span class=\"hljs-variable\">$value</span>\n\nmy_model &lt;- <span class=\"hljs-built_in\">scrape_data</span>() %&gt;%\n  <span class=\"hljs-built_in\">clean_string_cols</span>() %&gt;%\n  <span class=\"hljs-built_in\">clean_numeric_cols</span>() %&gt;%\n  <span class=\"hljs-built_in\">run_model</span>()</code></pre><p>And that&#39;s it! Thanks for reading :)</p>\n<h2 class=\"heading\" id=\"caveats\">Caveats<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#caveats\">#</a></h2><p>The caveats of this method were mentioned above, but in sum:</p>\n<ul>\n<li>it&#39;s a bit messy</li>\n<li>libraries and namespaces are difficult to manage</li>\n</ul>\n<h2 class=\"heading\" id=\"alternatives\">Alternatives<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#alternatives\">#</a></h2><p>The patterns described here are usable, but you might be\ninterested in any of the following approaches for when you\ndecide to write code.</p>\n<h3 class=\"heading\" id=\"r-markdown\">R markdown<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#r-markdown\">#</a></h3><p>Won&#39;t writing your code in Rmarkdown files, knitting as\nnecessary, and potentially including child documents be better?\nYep, this is a totally viable option. It sometimes won&#39;t work\nin situations like package development, or wouldn&#39;t be the\nright choice if you&#39;re running a data analysis pipeline in\nproduction (there&#39;s no need for a pandoc render step to slow\nyou down), but it can be the right choice in many other\nsituations.</p>\n<p>It can also be combined with this approach: write all of your\nlogic in plain R scripts through the modules pattern, and use\nthe R markdown file as an index file to combine all of them\ntogether. This way, you can use R markdown to focus on a\nnarrative about your analysis and use the R modules to\ncontainerize the code. You can definitely annotate the code\nitself by writing the modules in R markdown, but it can often\nbe cleaner to have simply self-documenting code through named\nlogic in plain R files.</p>\n<h3 class=\"heading\" id=\"third-party-packages\">Third-party packages<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#third-party-packages\">#</a></h3><p>There are some packages created to handle this pattern, namely\nthe <a target='_blank'  href=\"https://github.com/klmr/box\"><code>box</code></a> package and the\n<a target='_blank'  href=\"https://github.com/rticulate/import\"><code>import</code></a> packages.</p>\n<p>These provide ways to import functions from scripts and\npackages into aliased forms without altering the search path.\nIf you don&#39;t mind adding a dependency to your package or\nproject, these are great.</p>\n<h3 class=\"heading\" id=\"writing-your-own-personal-package\">Writing your own personal package<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#writing-your-own-personal-package\">#</a></h3><p>I&#39;ve seen this suggested in a few StackOverflow posts. It works\nfor some and not for others; the break point is up to you.</p>\n<p>One note is that modularizing your code can be thought of as a\nprecursor to creating a package for it. You&#39;ve already\nseparated your code into named functions, a package is just a\nfew steps more than that.</p>\n<p>A second note is that packages handle the messy library\nsituation quite well, being able to use functions from other\nlibraries without adding them to the search path or masking\nexisting functions.</p>\n"}