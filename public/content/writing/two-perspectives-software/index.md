{"data":{"title":"Unix against the world","subtitle":"Two perspectives on writing software","date":"2022-02-17T00:00:00.000Z"},"toc":[{"level":2,"slug":"two-perspectives","title":"Two perspectives"},{"level":2,"slug":"example-1-marked-js","title":"Example 1: Marked.js"},{"level":2,"slug":"example-2-front-end-frameworks","title":"Example 2: Front-end frameworks"},{"level":2,"slug":"tldr-simple-and-complex-always-come-together","title":"TLDR: Simple and complex always come together"}],"content":"<h2 class=\"heading\" id=\"two-perspectives\">Two perspectives<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#two-perspectives\">#</a></h2><p>Here are two perspectives on writing software:</p>\n<ol>\n<li>A piece of software should be restricted in scope to a\nsingle function. It should do one thing and do it well.</li>\n<li>A piece of software should do what the user needs; if\nadditional features are wanted, it should implement them.</li>\n</ol>\n<p>The first principle is the core of the Unix philosophy. In a\nsentence, Unix is a family of operating systems, the design of\nwhich have made their way into the core of macOS, Linux, and\nAndroid machines. Unix developers believe that by attempting to\nkeep things obscenely simple, even prioritizing simplicity of\nimplementation over &quot;correctness,&quot; software like Unix can live\nfor a very, very long time.</p>\n<p>The second principle is what has come to represent... almost\neverything else. Most software projects will acknowledge that\nsome things are out of scope and will refuse to implement them\nif requested, but the reality is that people want to do more\nwith a piece of software than its creators originally intended.\nFeatures are often added over time, expanding a project&#39;s scope\nbeyond what its original vision or function.</p>\n<p>These might not necessarily be conflicting if you really,\nreally tried hard to make them work together. But they&#39;re\npretty conflicting. Real projects building software often\ndemands we choose between these two principles to fit our\ncurrent needs.</p>\n<h2 class=\"heading\" id=\"example-1-marked-js\">Example 1: Marked.js<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#example-1-marked-js\">#</a></h2><p>Consider <a target='_blank'  href=\"https://marked.js.org\">marked.js</a>, a JavaScript\nengine to render Markdown content into HTML. I use this nearly\nevery week to translate writer-friendly Markdown into\nreader-friendly HTML, but often run into frustrating issues\nthat the creators are hesitant to implement. How should\nmarked.js render content like footnotes, which aren&#39;t part of\nthe <a target='_blank'  href=\"two-perspectives-software/commonmark.org/\">CommonMark specification</a> that marked.js\nimplements? How should marked.js handle YAML metadata, which\nare used ubiquitously with Markdown documents despite not being\npart of the Markdown language? Should marked.js stick to the\nUnix philosophy by restricting its scope to a single set of\nclearly-defined rules, or should they try to be pragmatic and\nfollow user requests for features?</p>\n<p>Marked.js has tried to follow the first paradigm somewhat,\nadhering to its stated goal of implementing three things: the\nCommonMark spec, the original markdown.pl implementation that\npreceded it, and the slightly more featureful Github-flavored\nMarkdown (GFM). Ways to parse YAML metadata is strictly out of\nscope. But the CommonMark and GFM have evolved over time, with\nGFM even defining a set of rules for footnotes last year. Now\nMarked.js is forced to expand in scope; even as their stated\npurpose of implementing three specifications doesn&#39;t change,\nthe fact that these three specifications themselves are\nchanging mean that Marked.js has to adapt and potentially\ncomplicate its codebase with new features.</p>\n<h2 class=\"heading\" id=\"example-2-front-end-frameworks\">Example 2: Front-end frameworks<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#example-2-front-end-frameworks\">#</a></h2><p>The other big example in my mind lies in the architecture of\nfront-end frameworks. I&#39;ll compare Angular and React here, two\nof the most popular.</p>\n<p>React embodies the first perspective. The library does one\nsingle thing of building a component tree, and requires\ndevelopers to take on additional dependencies for any common\ntask beyond that. Styling, routing, fast refresh and developer\ntooling, and even rendering to the DOM itself are considered\nout of scope for the core React library, which does the single\njob of assembling components. React benefits from this in being\na fairly simple framework.<sup id=\"fn-1\"><a href=\"#note-1\">1</a></sup> The narrow scope of the library means that\nReact has more freedom to drastically alter its language\nthrough features like hooks (with React 17), since it&#39;s still\njust changing one thing instead of addressing every necessary\nchange across styles, transitions, server-side rendering, and\nso on. Finally, being limited in scope means that those\nunimplemented features are left to the React user community,\nwhich often results in a proliferation of different appproaches\nthat let each project find its own best combination of\npackages.</p>\n<p>Angular embodies the second perspective, serving as more of a\nmonolith that has many features out-of-the-box. All of the\nabove features that are missing from React are packed into the\nlibrary, and the project even goes as far as pushing developers\nto use Typescript, in other words moving even variable typing\ninto its scope. The first iteration of Angular (AngularJS) was\nheavily criticized for this approach, most notably for having a\nlarger-than-necessary bundle size but more generally for trying\nto do too many things at once and succeeding only partly. With\nthe adoption of tree-shaking and the more modular structure of\nAngular to allow for removal of unused code during production,\nthe bundle size issue became much less of a problem, but\ndevelopers are still left with the conceptual issue of\nbreadth-against-focus.</p>\n<p>React wins here for me, but there&#39;s still a pretty big\ntradeoff. I get simplicity from the core framework, but in\nreturn every React app I&#39;ve built always involves additional\ndecisions, debates, and endless version increments for the\nnumerous packages I have to install alongside React itself. The\nsimplicity of the core framework means that the complexity many\nmodern web apps have is just offloaded to the framework user.</p>\n<h2 class=\"heading\" id=\"tldr-simple-and-complex-always-come-together\">TLDR: Simple and complex always come together<a class=\"heading-link\" href=\"#frontmatter\">ðŸ ‘</a><a class=\"heading-link\" href=\"#tldr-simple-and-complex-always-come-together\">#</a></h2><p>The Unix philosophy is a bit of a paradox. By making their\ntools supremely simple, limited in scope, and relying on\nmodularity rather than monolithic gigantic tools, Unix-inspired\ntools are mostly successful in providing consistently\nhigh-quality tools. But because these tools are limited in\nscope, complexity is relegated to systems that are built on top\nof them. Users of these programs often have to mix and match\noften dozens of these tools to produce software with the\ndesired featureset.</p>\n<p>Don&#39;t get me wrong: the simplicity afforded by the Unix\nphilosophy to me is invaluable, and I think preferring modular\nand simple tools should be a value all developers hold. Even\nwhen complex systems have to be built on top of supposedly\nsimple tools, the fact that the underlying tools have been\nfocused and rigidly defined in scope means that they at least\ndo their single purpose extremely well.</p>\n<p>All I hope to share is the observation that all software\nrequires some compromise between these two perspectives. The\nchoice to focus a project&#39;s scope comes at a cost, often\nrequiring developers to make pragmatic decisions and choose a\nmonolith over a module based on their own needs. Unix-inspired\nsoftware is undoubtedly &quot;better&quot; in maintainability and\nlongetivity, but sometimes that&#39;s just not what helps us most.</p>\n<hr/><ol><li id=\"note-1\">or at least much simpler than it\ncould have been <a class=\"backlink\" href=\"#fn-1\">â†©</a></li></ol>"}