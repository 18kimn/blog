{"data":{"title":"codexer","subtitle":"a tool for turning code into books","date":"2021-10-21T00:00:00.000Z","banner":"codexer-example.png"},"content":"<h3 id=\"quick-links\">Quick links</h3>\n<p><a href=\"https://github.com/18kimn/codexer\">Source code</a></p>\n<p><a href=\"https://www.npmjs.com/package/codexer\">NPM location</a></p>\n<p>Some sources of inspiration:</p>\n<ul>\n<li><a href=\"https://www.pagedjs.org/\">Pagedjs</a></li>\n<li><a href=\"https://mitpress.mit.edu/books/code-creative-medium\">Code as creative medium</a></li>\n</ul>\n<h3 id=\"overview\">Overview</h3>\n<p>The de-facto way of looking at code is as a dry, machine-like,\nmonospaced, almost monotonous form of giving instructions to the\ncomputer. But I think code is just as creative, colorful, vivid, and\n<em>textual</em> as all of the other forms of information we consume. Our\nunconscious perception of a divide between computer programs and other\nforms of text prevents us from critiquing the actual language of code,\ndown to its individual variables and functions.</p>\n<p>This (small) project tries to push back on that by providing a method\nto make folders of code into books -- or really, just printable PDFs.\nIt features syntax highlighting with\n<a href=\"https://highlightjs.org/\">highlight.js</a>, automagical formatting with\n<a href=\"https://prettier.io/\">prettier</a>, and a table of contents with page\nnumbers from my own hacky coding.</p>\n<p>The actual PDF generation is done with\n<a href=\"https://github.com/marcbachmann/node-html-pdf/issues\">html-pdf</a> with\nsome processing done in\n<a href=\"https://www.npmjs.com/package/pdf-parse\">pdf-parse</a>.</p>\n<p><strong>View an example PDF of what this tool can make\n<a href=\"https://nathankim.name/files/codexer.pdf\">here</a>.</strong></p>\n<h3 id=\"usage-cli\">Usage (CLI)</h3>\n<p>Install with <code>npm install --global codexer</code>.</p>\n<p>If you&#39;re new to Node, feel free to check out\n<a href=\"https://heynode.com/tutorial/install-nodejs-locally-nvm/\">this guide</a>.</p>\n<pre><code class=\"hljs \">codexer [options]\n\nOptions:\n  -V, --version               output the version number\n  -t, --target &lt;path&gt;         The path to a directory to be made into a PDF. The flag can be omitted.\n  -a, --author &lt;name&gt;         will be filled in on the title page and every header\n  -o, --outPath &lt;path&gt;        output location. Tilde notation currently not accepted :(\n  -d, --dry                   Add -d to enable a dry run that produces only a JSON\n      representing the order in which files will be assembled.\n  -j, --json &lt;path&gt;           Pass in the location of a JSON file to specify your own order of files instead.\n      Most useful after trying out the -d option to see what a config should look like.\n  -dh --dryHTML               Like the dry run option, but produces just HTML output. No page numbers though :(\n  -s --stylePath &lt;path&gt;       Path to a HTML file with configurations that will be used to style the PDF.\n  -q --quietly                Suppress all debugging messages\n  -w --width &lt;length&gt;         Page width\n  -h --height &lt;length&gt;        Page height\n  -e --exclude &lt;patterns...&gt;  Specify regex patterns for files to exclude. Default excludes node_modules,\n                              .git, yarn.lock and package-lock.json, and .env files.\n                              Codexer also excludes any non-text encoded files; this cannot be altered.\n  --help                      display help for command</code></pre><h3 id=\"usage-as-a-node-module\">Usage (as a Node module)</h3>\n<p>You should probably stick to using it as a CLI tool or for just\nmessing around, as it&#39;s not really ready for production. But if you\nwant, you can install with <code>npm install codexer</code> in your Node project.\nThen use it as follows:</p>\n<pre><code class=\"hljs js\">const codexer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;codexer&#x27;</span>)\n<span class=\"hljs-comment\">// or</span>\nimport codexer from <span class=\"hljs-string\">&#x27;codexer&#x27;</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">codexer</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;.&#x27;</span>)</span></span>\n<span class=\"hljs-comment\">// Finished! PDF is located at /tmp/codexer/[your directory basename].pdf</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">codexer</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;.&#x27;</span>, {outPath: <span class=\"hljs-string\">&#x27;output.pdf&#x27;</span>})</span></span>\n<span class=\"hljs-comment\">// Finished! PDF is located at [path to your directory].pdf</span></code></pre><p>All of the CLI options are available for use in the npm version.</p>\n<h3 id=\"npx\">npx?</h3>\n<p>You can also call it as a single-use tool with npx if you have Node\ninstalled by prefixing npx to the codexer commands, e.g. by running\n<code>npx codexer .</code>.</p>\n<p>The problem is that phantomJS and pdf-parse, which this tool depends\non, are incredibly large (the local node_modules/ folder on my machine\ncomes out to 184Mb). Download, load, and install times are quite long\nbecause of this.</p>\n<p>If you intend on using this tool more than once, I&#39;d recommend just\ninstalling it globally.</p>\n<h3 id=\"if-this-doesnt-fit-your-use-case\">If this doesn&#39;t fit your use case</h3>\n<p>All in all, it probably doesn&#39;t! Please, please feel free to download\nand alter it if you want an adjustment.</p>\n<h3 id=\"personal-notes\">Personal notes</h3>\n<p>Honestly, this is just one of those cool-but-not-that-cool side\nprojects I&#39;ve feel like I&#39;ve distracted myself with these days. But it\nis cool!</p>\n<p>I&#39;m looking for more tangible ways to hold and digest code, and more\nthan anything else critically analyze code itself (e.g. rather than\nits periphery -- the funders, the things it is used for, etc.). If you\nknow of any links on this or have creative ideas, please send them my\nway!!</p>\n"}