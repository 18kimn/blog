{"data":{"title":"reso","subtitle":"An esoteric R-based programming style","date":"2021-09-05T00:00:00.000Z","banner":"banner.png"},"toc":[{"level":3,"slug":"introduction","title":"Introduction"},{"level":3,"slug":"setup-and-installation","title":"Setup and installation"},{"level":3,"slug":"how-it-works","title":"How it works"},{"level":3,"slug":"caveats","title":"Caveats"},{"level":3,"slug":"a-demonstration","title":"A demonstration"},{"level":3,"slug":"expanding-to-almost-the-entire-r-universe","title":"Expanding to almost the entire R universe"},{"level":4,"slug":"part-1-the-alphabet","title":"Part 1: The alphabet"},{"level":3,"slug":"part-2-non-alphabetical-characters","title":"Part 2: Non-alphabetical characters"},{"level":3,"slug":"some-notes-about-motivation-and-learning","title":"Some notes about motivation and learning"}],"content":"<h3 class=\"heading\" id=\"introduction\">Introduction<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#introduction\">#</a></h3><p>Have you ever been frustrated at R, maybe after reading too\nmany rude StackOverflow or R-help threads? (me too) Well, what\nif we took R and instead of helping making it accessible and\nfun, made all of those esoteric, argon-y, incredibly annoying,\nand unreadable parts much worse?</p>\n<p>Enter <code>reso</code>, a library and R-based programming style. Only the\nfollowing symbols from R are allowed:</p>\n<p style=\"text-align:center\">\n  (), [, ], !, 0, +, and “,” (the comma).\n</p>\n\n<p>Along with four functions to make <code>reso</code> “go.” They are really\njust simplified and narrower versions of existing R utilities:</p>\n<ul>\n<li><p>s(): An alias for <code>substr(string, i)</code>. Used to get a letter\nfrom a string</p>\n</li>\n<li><p>p(): An alias for <code>paste(..., collapse = &quot;&quot;)</code>, to concatenate\nstrings</p>\n</li>\n<li><p>x(): Interpret and execute a string as an R expression</p>\n</li>\n<li><p>d(): an alias for\n<a target='_blank'  href=\"https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/deparse\">deparse()</a></p>\n</li>\n</ul>\n<p>And that’s it! Not even spaces, line breaks, or tabs are\nallowed! Happy programming :)</p>\n<h3 class=\"heading\" id=\"setup-and-installation\">Setup and installation<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#setup-and-installation\">#</a></h3><p>For now, you can install the package from the R console with\n<code>devtools::install_github(&quot;18kimn/reso&quot;)</code>. I&#39;ve submitted the\npackage to CRAN, so hopefully this can soon be updated!</p>\n<p>You can view the package implementation details at\n<a target='_blank'  href=\"https://github.com/18kimn/reso\">github.com/18kimn/reso</a>.</p>\n<h3 class=\"heading\" id=\"how-it-works\">How it works<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#how-it-works\">#</a></h3><p>There’s a few more things that should be said.</p>\n<p>This style is able to work because R is able to interpret\nstrings as expressions, and through hacky (some might say c l e\nv e r) tricks you can grab those strings from native R objects\nthat are available to you.</p>\n<p>The general pattern using this is as follows:</p>\n<ol>\n<li>Find a hacky way to coerce values to built-in objects, like\n<code>FALSE</code> or <code>logical(0)</code></li>\n<li>Interpret that value as a string with <code>d()</code>, so that\n<code>FALSE</code> becomes <code>&quot;FALSE&quot;</code> and so on.</li>\n<li>Pull a letter of that string out with <code>s()</code></li>\n<li>Repeat and combine with <code>p()</code> until we can make a function\nname</li>\n<li>Evaluate the string as an R expression with <code>x()</code>.</li>\n<li>If that worked, you have a new function available to you!\nRepeat ad infinitum until your code is completely\nnonsensical.</li>\n</ol>\n<h3 class=\"heading\" id=\"caveats\">Caveats<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#caveats\">#</a></h3><p>There are some things that I’m not sure if the style can do as\nof now. Probably the biggest issue is that a programmer can’t\nsave variables to the namespace. The <code>reso_validate()</code> function\nis super hacky, so much so that it just marks as valid those\nstrings or file expressions which have only <code>reso</code> characters.\nThis means that assignment to new characters is not allowed.\nIt’d also break because the <code>d()</code> function operates in the\nparent frame instead of in the global environment with no\nescape hatch. The parent frame would most often be the context\ninside of <code>x()</code> and would be “forgotten” after execution,\nmeaning that variables can’t really be saved.</p>\n<h3 class=\"heading\" id=\"a-demonstration\">A demonstration<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#a-demonstration\">#</a></h3><p><strong>Goal: Generate the output <code>[1] 0 1</code></strong></p>\n<p>In other words, create the output we would receive if we were\ntyping <code>c(0, 1)</code> in vanilla R.</p>\n<p>Let’s start by getting just the letter “c” as a string, which\nwe can do by:</p>\n<ol>\n<li><p>Produce <code>character(0)</code> by generating an empty string with\nR’s <code>paste</code> or reso’s <code>p</code>, then get the 0th element of that\nresult.</p>\n</li>\n<li><p>Convert the value <code>character(0)</code> into character, e.g. \n<code>&quot;character(0)&quot;</code>. This can be done with R’s <code>deparse</code> or\nreso’s <code>d</code>.</p>\n</li>\n<li><p>Get the first letter of “character(0)”, via R’s <code>substr</code> or\nreso’s <code>s</code>.</p>\n</li>\n</ol>\n<p>Those steps as code:</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-selector-tag\">p</span>()<span class=\"hljs-selector-attr\">[0]</span>\n#&gt; <span class=\"hljs-built_in\">character</span>(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-function\"><span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>[<span class=\"hljs-number\">0</span>])</span></span>\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-string\">&quot;numeric(0)&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">s</span><span class=\"hljs-params\">(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>))\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-string\">&quot;c&quot;</span></code></pre><p>Next, we’d want to turn this string into the R expression\n<code>c(0, 1)</code>. To do this, we can:</p>\n<ol>\n<li>Force R to interpret “c” as the native function <code>c</code>, by\nusing <code>parse</code> and then <code>eval</code> in R, or using the <code>x</code>\nfunction[^1] in reso.</li>\n<li>Generate 1 by coercing 0 to <code>TRUE</code> with <code>!0</code>, and combining\n<code>TRUE</code> with <code>numeric(0)</code> to force <code>TRUE</code> to be numeric (or\n1). This requires our new version of <code>c()</code>.</li>\n<li>Combine all of our above steps with a set of parens and a\n0!</li>\n</ol>\n<pre><code class=\"hljs r\"><span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))\n#&gt; function (...)  <span class=\"hljs-selector-class\">.Primitive</span>(<span class=\"hljs-string\">&quot;c&quot;</span>)\n<span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))(!<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-selector-attr\">[0]</span>)\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))(<span class=\"hljs-number\">0</span>,<span class=\"hljs-built_in\">x</span>(<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(<span class=\"hljs-selector-tag\">p</span>()<span class=\"hljs-selector-attr\">[0]</span>)))(!<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-selector-attr\">[0]</span>))\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span></code></pre><p>Yay!</p>\n<h3 class=\"heading\" id=\"expanding-to-almost-the-entire-r-universe\">Expanding to almost the entire R universe<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#expanding-to-almost-the-entire-r-universe\">#</a></h3><h4 class=\"heading\" id=\"part-1-the-alphabet\">Part 1: The alphabet<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#part-1-the-alphabet\">#</a></h4><p>This could have been a bit of a puzzle to figure out, and\npotentially impossible. R has a fair number of native values,\nbut many letters are just hard to figure out or produce via\ntype coercion.</p>\n<p>Luckily, R provides an object that makes this almost trivial:\nthe <code>letters</code> array!</p>\n<p>To get it, we need:</p>\n<ol>\n<li>“l”, from <code>logical(0)</code></li>\n<li>Two “e”s, from <code>integer(0)</code></li>\n<li>Two “t”s, from <code>integer(0)</code></li>\n<li>One “r”, from <code>integer(0)</code></li>\n<li>One “s”, from the eleventh letter of the deparse function\nexpression for <code>s()</code>.[^2]</li>\n</ol>\n<p>The code representation of this is below. <code>c()</code> and numbers are\nused instead of their <code>reso</code> equivalents for readability.[^3]</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(!0[0])) # the first letter of <span class=\"hljs-string\">&quot;logical(0)&quot;</span>, or <span class=\"hljs-string\">&quot;l&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;l&quot;</span>\nc() + !0 # makes integer(0) <span class=\"hljs-keyword\">by</span> adding TRUE and NULL\n#&gt; integer(0)\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4) # turns integer(0) -&gt; <span class=\"hljs-string\">&quot;integer(0)&quot;</span> -&gt; <span class=\"hljs-string\">&quot;e&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;e&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 3) #<span class=\"hljs-string\">&quot;t&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;t&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 7) #<span class=\"hljs-string\">&quot;r&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;r&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(s)[1], 11) #<span class=\"hljs-string\">&quot;s&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;s&quot;</span>\n\n#combining\nx(p(\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(!0[0])),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 3),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() +  !0), 3),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 7),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(s)[1], 11)\n))\n#&gt;  [1] <span class=\"hljs-string\">&quot;a&quot;</span> <span class=\"hljs-string\">&quot;b&quot;</span> <span class=\"hljs-string\">&quot;c&quot;</span> <span class=\"hljs-string\">&quot;d&quot;</span> <span class=\"hljs-string\">&quot;e&quot;</span> <span class=\"hljs-string\">&quot;f&quot;</span> <span class=\"hljs-string\">&quot;g&quot;</span> <span class=\"hljs-string\">&quot;h&quot;</span> <span class=\"hljs-string\">&quot;i&quot;</span> <span class=\"hljs-string\">&quot;j&quot;</span> <span class=\"hljs-string\">&quot;k&quot;</span> <span class=\"hljs-string\">&quot;l&quot;</span> <span class=\"hljs-string\">&quot;m&quot;</span> <span class=\"hljs-string\">&quot;n&quot;</span> <span class=\"hljs-string\">&quot;o&quot;</span> <span class=\"hljs-string\">&quot;p&quot;</span> <span class=\"hljs-string\">&quot;q&quot;</span> <span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-string\">&quot;s&quot;</span> <span class=\"hljs-string\">&quot;t&quot;</span> <span class=\"hljs-string\">&quot;u&quot;</span> <span class=\"hljs-string\">&quot;v&quot;</span> <span class=\"hljs-string\">&quot;w&quot;</span> <span class=\"hljs-string\">&quot;x&quot;</span> <span class=\"hljs-string\">&quot;y&quot;</span> <span class=\"hljs-string\">&quot;z&quot;</span></code></pre><p>We can subset letters from here in order to form arbitrary\nwords, and thus nearly all R commands.</p>\n<h3 class=\"heading\" id=\"part-2-non-alphabetical-characters\">Part 2: Non-alphabetical characters<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#part-2-non-alphabetical-characters\">#</a></h3><p>The last trick in getting this to be an almost-all-of-R style\nis in using the <code>builtins</code> vector. <code>builtins</code> contains the\nnames of all built-in functions in R, many of which include\nnon-alphabetical operators like +, -, (, :, and so on. You\ncould subset the builtins array for these, which would then\nunlock the door to almost all of R.</p>\n<h3 class=\"heading\" id=\"some-notes-about-motivation-and-learning\">Some notes about motivation and learning<a class=\"heading-link\" href=\"#frontmatter\">🠑</a><a class=\"heading-link\" href=\"#some-notes-about-motivation-and-learning\">#</a></h3><p>This is not meant to be a useful or practical programming tool.\nIt is meant to show the opposite, that being esoteric is\nuseless and using simpler, abstracted logic can be way more\nhelpful.[^4]</p>\n<p>Compared to languages like JavaScript, R stands out in being\nmore accessible and friendly. Sometimes programmers attempt to\nbe as concise as possible, preferring syntax like arrow\nfunctions to jam as much code as possible into a single line.\nLogical operators like ‘&amp;&amp;’ and ‘||’ are used via a side\neffect as if statements themselves instead of as just logical\noperators.</p>\n<p>In contrast, the R community tends to view being verbose as a\nfeature. The base R libraries export thousands of functions to\nhandle many general cases and provide a higher level of\nabstraction. Pipes in R are encouraged in order to demystify\ncode and reduce mistakes, and tools like the R linter even\nencourage placing every statement after a pipe on a new line to\nencourage even more readability.</p>\n<p>Of course, R still has lots of room to improve in becoming\naccessible. Let’s help each other get there by making the R\ncommunity welcoming and fun!</p>\n<p>[^1] for “execute”, or “expression.” Your choice :)</p>\n<p>[^2] If you can think of a better way, let me know :’)</p>\n<p>[^3] LOL</p>\n<p>[^4] of course, it was also just a fun/silly little side\nproject for myself.</p>\n"}