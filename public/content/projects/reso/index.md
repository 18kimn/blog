{"data":{"title":"reso","subtitle":"An esoteric R-based programming style","date":"2021-09-05T00:00:00.000Z","banner":"banner.png"},"content":"<h3 id=\"introduction\">Introduction</h3>\n<p>Have you ever been frustrated at R, maybe after reading too many rude\nStackOverflow or R-help threads? (me too) Well, what if we took R and\ninstead of helping making it accessible and fun, made all of those\nesoteric, argon-y, incredibly annoying, and unreadable parts much\nworse?</p>\n<p>Enter <code>reso</code>, a library and R-based programming style. Only the\nfollowing symbols from R are allowed:</p>\n<p style=\"text-align:center\">\n  (), [, ], !, 0, +, and “,” (the comma).\n</p>\n\n<p>Along with four functions to make <code>reso</code> “go.” They are really just\nsimplified and narrower versions of existing R utilities:</p>\n<ul>\n<li><p>s(): An alias for <code>substr(string, i)</code>. Used to get a letter from a\nstring</p>\n</li>\n<li><p>p(): An alias for <code>paste(..., collapse = &quot;&quot;)</code>, to concatenate\nstrings</p>\n</li>\n<li><p>x(): Interpret and execute a string as an R expression</p>\n</li>\n<li><p>d(): an alias for\n<a href=\"https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/deparse\">deparse()</a></p>\n</li>\n</ul>\n<p>And that’s it! Not even spaces, line breaks, or tabs are allowed!\nHappy programming :)</p>\n<h3 id=\"setup-and-installation\">Setup and installation</h3>\n<p>For now, you can install the package from the R console with\n<code>devtools::install_github(&quot;18kimn/reso&quot;)</code>. I&#39;ve submitted the package\nto CRAN, so hopefully this can soon be updated!</p>\n<p>You can view the package implementation details at\n<a href=\"https://github.com/18kimn/reso\">github.com/18kimn/reso</a>.</p>\n<h3 id=\"how-it-works\">How it works</h3>\n<p>There’s a few more things that should be said.</p>\n<p>This style is able to work because R is able to interpret strings as\nexpressions, and through hacky (some might say c l e v e r) tricks you\ncan grab those strings from native R objects that are available to\nyou.</p>\n<p>The general pattern using this is as follows:</p>\n<ol>\n<li>Find a hacky way to coerce values to built-in objects, like\n<code>FALSE</code> or <code>logical(0)</code></li>\n<li>Interpret that value as a string with <code>d()</code>, so that <code>FALSE</code>\nbecomes <code>&quot;FALSE&quot;</code> and so on.</li>\n<li>Pull a letter of that string out with <code>s()</code></li>\n<li>Repeat and combine with <code>p()</code> until we can make a function name</li>\n<li>Evaluate the string as an R expression with <code>x()</code>.</li>\n<li>If that worked, you have a new function available to you! Repeat\nad infinitum until your code is completely nonsensical.</li>\n</ol>\n<h3 id=\"caveats\">Caveats</h3>\n<p>There are some things that I’m not sure if the style can do as of now.\nProbably the biggest issue is that a programmer can’t save variables\nto the namespace. The <code>reso_validate()</code> function is super hacky, so\nmuch so that it just marks as valid those strings or file expressions\nwhich have only <code>reso</code> characters. This means that assignment to new\ncharacters is not allowed. It’d also break because the <code>d()</code> function\noperates in the parent frame instead of in the global environment with\nno escape hatch. The parent frame would most often be the context\ninside of <code>x()</code> and would be “forgotten” after execution, meaning that\nvariables can’t really be saved.</p>\n<h3 id=\"a-demonstration\">A demonstration</h3>\n<p><strong>Goal: Generate the output <code>[1] 0 1</code></strong></p>\n<p>In other words, create the output we would receive if we were typing\n<code>c(0, 1)</code> in vanilla R.</p>\n<p>Let’s start by getting just the letter “c” as a string, which we can\ndo by:</p>\n<ol>\n<li><p>Produce <code>character(0)</code> by generating an empty string with R’s\n<code>paste</code> or reso’s <code>p</code>, then get the 0th element of that result.</p>\n</li>\n<li><p>Convert the value <code>character(0)</code> into character, e.g. \n<code>&quot;character(0)&quot;</code>. This can be done with R’s <code>deparse</code> or reso’s\n<code>d</code>.</p>\n</li>\n<li><p>Get the first letter of “character(0)”, via R’s <code>substr</code> or reso’s\n<code>s</code>.</p>\n</li>\n</ol>\n<p>Those steps as code:</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-selector-tag\">p</span>()<span class=\"hljs-selector-attr\">[0]</span>\n#&gt; <span class=\"hljs-built_in\">character</span>(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-function\"><span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>[<span class=\"hljs-number\">0</span>])</span></span>\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-string\">&quot;numeric(0)&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">s</span><span class=\"hljs-params\">(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>))\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-string\">&quot;c&quot;</span></code></pre><p>Next, we’d want to turn this string into the R expression <code>c(0, 1)</code>.\nTo do this, we can:</p>\n<ol>\n<li>Force R to interpret “c” as the native function <code>c</code>, by using\n<code>parse</code> and then <code>eval</code> in R, or using the <code>x</code> function[^1] in\nreso.</li>\n<li>Generate 1 by coercing 0 to <code>TRUE</code> with <code>!0</code>, and combining <code>TRUE</code>\nwith <code>numeric(0)</code> to force <code>TRUE</code> to be numeric (or 1). This\nrequires our new version of <code>c()</code>.</li>\n<li>Combine all of our above steps with a set of parens and a 0!</li>\n</ol>\n<pre><code class=\"hljs r\"><span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))\n#&gt; function (...)  <span class=\"hljs-selector-class\">.Primitive</span>(<span class=\"hljs-string\">&quot;c&quot;</span>)\n<span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))(!<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-selector-attr\">[0]</span>)\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">x</span><span class=\"hljs-params\">(s(d(p()</span></span><span class=\"hljs-selector-attr\">[0]</span>)))(<span class=\"hljs-number\">0</span>,<span class=\"hljs-built_in\">x</span>(<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(<span class=\"hljs-selector-tag\">p</span>()<span class=\"hljs-selector-attr\">[0]</span>)))(!<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-selector-attr\">[0]</span>))\n#&gt; <span class=\"hljs-selector-attr\">[1]</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span></code></pre><p>Yay!</p>\n<h3 id=\"expanding-to-almost-the-entire-r-universe\">Expanding to almost the entire R universe</h3>\n<h4 id=\"part-1-the-alphabet\">Part 1: The alphabet</h4>\n<p>This could have been a bit of a puzzle to figure out, and potentially\nimpossible. R has a fair number of native values, but many letters are\njust hard to figure out or produce via type coercion.</p>\n<p>Luckily, R provides an object that makes this almost trivial: the\n<code>letters</code> array!</p>\n<p>To get it, we need:</p>\n<ol>\n<li>“l”, from <code>logical(0)</code></li>\n<li>Two “e”s, from <code>integer(0)</code></li>\n<li>Two “t”s, from <code>integer(0)</code></li>\n<li>One “r”, from <code>integer(0)</code></li>\n<li>One “s”, from the eleventh letter of the deparse function\nexpression for <code>s()</code>.[^2]</li>\n</ol>\n<p>The code representation of this is below. <code>c()</code> and numbers are used\ninstead of their <code>reso</code> equivalents for readability.[^3]</p>\n<pre><code class=\"hljs r\"><span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(!0[0])) # the first letter of <span class=\"hljs-string\">&quot;logical(0)&quot;</span>, or <span class=\"hljs-string\">&quot;l&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;l&quot;</span>\nc() + !0 # makes integer(0) <span class=\"hljs-keyword\">by</span> adding TRUE and NULL\n#&gt; integer(0)\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4) # turns integer(0) -&gt; <span class=\"hljs-string\">&quot;integer(0)&quot;</span> -&gt; <span class=\"hljs-string\">&quot;e&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;e&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 3) #<span class=\"hljs-string\">&quot;t&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;t&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 7) #<span class=\"hljs-string\">&quot;r&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;r&quot;</span>\n<span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(s)[1], 11) #<span class=\"hljs-string\">&quot;s&quot;</span>\n#&gt; [1] <span class=\"hljs-string\">&quot;s&quot;</span>\n\n#combining\nx(p(\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(!0[0])),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 3),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() +  !0), 3),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 4),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(c() + !0), 7),\n  <span class=\"hljs-built_in\">s</span>(<span class=\"hljs-built_in\">d</span>(s)[1], 11)\n))\n#&gt;  [1] <span class=\"hljs-string\">&quot;a&quot;</span> <span class=\"hljs-string\">&quot;b&quot;</span> <span class=\"hljs-string\">&quot;c&quot;</span> <span class=\"hljs-string\">&quot;d&quot;</span> <span class=\"hljs-string\">&quot;e&quot;</span> <span class=\"hljs-string\">&quot;f&quot;</span> <span class=\"hljs-string\">&quot;g&quot;</span> <span class=\"hljs-string\">&quot;h&quot;</span> <span class=\"hljs-string\">&quot;i&quot;</span> <span class=\"hljs-string\">&quot;j&quot;</span> <span class=\"hljs-string\">&quot;k&quot;</span> <span class=\"hljs-string\">&quot;l&quot;</span> <span class=\"hljs-string\">&quot;m&quot;</span> <span class=\"hljs-string\">&quot;n&quot;</span> <span class=\"hljs-string\">&quot;o&quot;</span> <span class=\"hljs-string\">&quot;p&quot;</span> <span class=\"hljs-string\">&quot;q&quot;</span> <span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-string\">&quot;s&quot;</span> <span class=\"hljs-string\">&quot;t&quot;</span> <span class=\"hljs-string\">&quot;u&quot;</span> <span class=\"hljs-string\">&quot;v&quot;</span> <span class=\"hljs-string\">&quot;w&quot;</span> <span class=\"hljs-string\">&quot;x&quot;</span> <span class=\"hljs-string\">&quot;y&quot;</span> <span class=\"hljs-string\">&quot;z&quot;</span></code></pre><p>We can subset letters from here in order to form arbitrary words, and\nthus nearly all R commands.</p>\n<h3 id=\"part-2-non-alphabetical-characters\">Part 2: Non-alphabetical characters</h3>\n<p>The last trick in getting this to be an almost-all-of-R style is in\nusing the <code>builtins</code> vector. <code>builtins</code> contains the names of all\nbuilt-in functions in R, many of which include non-alphabetical\noperators like +, -, (, :, and so on. You could subset the builtins\narray for these, which would then unlock the door to almost all of R.</p>\n<h3 id=\"some-notes-about-motivation-and-learning\">Some notes about motivation and learning</h3>\n<p>This is not meant to be a useful or practical programming tool. It is\nmeant to show the opposite, that being esoteric is useless and using\nsimpler, abstracted logic can be way more helpful.[^4]</p>\n<p>Compared to languages like JavaScript, R stands out in being more\naccessible and friendly. Sometimes programmers attempt to be as\nconcise as possible, preferring syntax like arrow functions to jam as\nmuch code as possible into a single line. Logical operators like ‘&amp;&amp;’\nand ‘||’ are used via a side effect as if statements themselves\ninstead of as just logical operators.</p>\n<p>In contrast, the R community tends to view being verbose as a feature.\nThe base R libraries export thousands of functions to handle many\ngeneral cases and provide a higher level of abstraction. Pipes in R\nare encouraged in order to demystify code and reduce mistakes, and\ntools like the R linter even encourage placing every statement after a\npipe on a new line to encourage even more readability.</p>\n<p>Of course, R still has lots of room to improve in becoming accessible.\nLet’s help each other get there by making the R community welcoming\nand fun!</p>\n<p>[^1] for “execute”, or “expression.” Your choice :)</p>\n<p>[^2] If you can think of a better way, let me know :’)</p>\n<p>[^3] LOL</p>\n<p>[^4] of course, it was also just a fun/silly little side project for\nmyself.</p>\n"}